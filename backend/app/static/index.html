<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BirdSound - Live Bird Detection</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
        }

        .header h1 {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header h1 span {
            font-size: 1.8rem;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        /* Language Switcher */
        .language-switcher {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255,255,255,0.1);
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
        }

        .language-switcher button {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .language-switcher button:hover {
            color: #fff;
            background: rgba(255,255,255,0.1);
        }

        .language-switcher button.active {
            color: #fff;
            background: rgba(78, 205, 196, 0.3);
        }

        .language-switcher .divider {
            color: #444;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff4444;
        }

        .status-dot.connected {
            background: #44ff44;
            box-shadow: 0 0 10px #44ff44;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 350px;
            grid-template-rows: auto 1fr;
            gap: 1rem;
            padding: 1rem;
            height: calc(100vh - 70px);
        }

        /* Live Detection Panel */
        .live-panel {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
            border-radius: 12px;
            padding: 1.5rem;
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .live-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .pulse {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff6b6b;
            animation: pulse 2s infinite;
        }

        .pulse.active {
            background: #51cf66;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
        }

        .current-detection {
            flex: 1;
        }

        .current-detection h2 {
            font-size: 2rem;
            margin-bottom: 0.25rem;
        }

        .current-detection .confidence {
            font-size: 1.2rem;
            color: #aaa;
        }

        .model-badges {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .model-badge {
            background: rgba(255,255,255,0.1);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .model-badge.agree {
            background: rgba(81, 207, 102, 0.2);
            border: 1px solid #51cf66;
        }

        /* Map Section */
        .map-section {
            background: #16213e;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .section-header {
            padding: 1rem;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-header h3 {
            font-size: 1rem;
            font-weight: 500;
        }

        #map {
            flex: 1;
            min-height: 300px;
        }

        /* Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        /* Timeline */
        .timeline-section {
            background: #16213e;
            border-radius: 12px;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .timeline-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .timeline-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            background: rgba(255,255,255,0.05);
            transition: background 0.2s;
        }

        .timeline-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .timeline-item.new {
            animation: slideIn 0.3s ease-out;
            background: rgba(81, 207, 102, 0.1);
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .timeline-icon {
            font-size: 1.5rem;
        }

        .timeline-content {
            flex: 1;
            min-width: 0;
        }

        .timeline-species {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .timeline-meta {
            font-size: 0.8rem;
            color: #888;
        }

        .timeline-confidence {
            font-weight: 600;
            color: #51cf66;
        }

        /* Stats Section */
        .stats-section {
            background: #16213e;
            border-radius: 12px;
            padding: 1rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #4ecdc4;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #888;
            margin-top: 0.25rem;
        }

        /* Chart */
        .chart-container {
            height: 150px;
            margin-top: 1rem;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .main-container {
                grid-template-columns: 1fr;
            }

            .sidebar {
                order: -1;
            }

            .header {
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .header-right {
                width: 100%;
                justify-content: space-between;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1><span>üê¶</span> BirdSound</h1>
        <div class="header-right">
            <div class="language-switcher">
                <button id="langDe" onclick="setLanguage('de')">DE</button>
                <span class="divider">|</span>
                <button id="langEn" onclick="setLanguage('en')">EN</button>
            </div>
            <div class="connection-status">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText" data-i18n="connecting">Verbinde...</span>
            </div>
        </div>
    </header>

    <main class="main-container">
        <!-- Live Detection Panel -->
        <section class="live-panel">
            <div class="live-indicator">
                <div class="pulse" id="pulseIndicator"></div>
                <span>LIVE</span>
            </div>
            <div class="current-detection">
                <h2 id="currentSpecies" data-i18n="waiting_detection">Warte auf Erkennung...</h2>
                <div class="confidence" id="currentConfidence"></div>
            </div>
            <div class="model-badges" id="modelBadges">
                <!-- Model badges will be inserted here -->
            </div>
        </section>

        <!-- Map Section -->
        <section class="map-section">
            <div class="section-header">
                <h3 data-i18n="detection_map">üìç Erkennungskarte</h3>
                <span id="mapCount" data-i18n-template="points">0 Punkte</span>
            </div>
            <div id="map"></div>
        </section>

        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Stats -->
            <section class="stats-section">
                <div class="section-header">
                    <h3 data-i18n="statistics">üìä Statistiken</h3>
                </div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="statTotal">0</div>
                        <div class="stat-label" data-i18n="detections">Erkennungen</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statSpecies">0</div>
                        <div class="stat-label" data-i18n="species">Arten</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statAvgConf">0%</div>
                        <div class="stat-label" data-i18n="avg_confidence">√ò Konfidenz</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statAgreement">0%</div>
                        <div class="stat-label" data-i18n="agreement">√úbereinstimmung</div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="speciesChart"></canvas>
                </div>
            </section>

            <!-- Timeline -->
            <section class="timeline-section">
                <div class="section-header">
                    <h3 data-i18n="timeline">üïê Timeline</h3>
                    <span id="timelineCount">0</span>
                </div>
                <div class="timeline-list" id="timelineList">
                    <!-- Timeline items will be inserted here -->
                </div>
            </section>
        </aside>
    </main>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // Configuration
        const API_BASE = window.location.origin;
        const WS_URL = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws/live`;

        // State
        let ws = null;
        let map = null;
        let markers = [];
        let detections = [];
        let speciesCounts = {};
        let chart = null;
        let currentLang = 'de';
        let translations = {};
        let speciesNames = {};

        // Translations (inline fallback)
        const TRANSLATIONS = {
            de: {
                connecting: 'Verbinde...',
                connected: 'Verbunden',
                disconnected: 'Getrennt',
                waiting_detection: 'Warte auf Erkennung...',
                detection_map: 'üìç Erkennungskarte',
                points: '{n} Punkte',
                statistics: 'üìä Statistiken',
                detections: 'Erkennungen',
                species: 'Arten',
                avg_confidence: '√ò Konfidenz',
                agreement: '√úbereinstimmung',
                timeline: 'üïê Timeline',
                confidence: 'Konfidenz',
                no_detection: 'Kein Vogel erkannt'
            },
            en: {
                connecting: 'Connecting...',
                connected: 'Connected',
                disconnected: 'Disconnected',
                waiting_detection: 'Waiting for detection...',
                detection_map: 'üìç Detection Map',
                points: '{n} points',
                statistics: 'üìä Statistics',
                detections: 'Detections',
                species: 'Species',
                avg_confidence: 'Avg Confidence',
                agreement: 'Agreement',
                timeline: 'üïê Timeline',
                confidence: 'Confidence',
                no_detection: 'No bird detected'
            }
        };

        // Bird icons for common species
        const BIRD_ICONS = {
            'Eurasian Blackbird': 'üê¶‚Äç‚¨õ',
            'Amsel': 'üê¶‚Äç‚¨õ',
            'European Robin': 'üê¶',
            'Rotkehlchen': 'üê¶',
            'Great Tit': 'üê§',
            'Kohlmeise': 'üê§',
            'Blue Tit': 'üê¶',
            'Blaumeise': 'üê¶',
            'House Sparrow': 'üê¶',
            'Haussperling': 'üê¶',
            'Common Starling': 'üê¶',
            'Star': 'üê¶',
            'default': 'üê¶'
        };

        // Get translation
        function t(key, vars = {}) {
            let text = translations[key] || TRANSLATIONS[currentLang]?.[key] || TRANSLATIONS.de[key] || key;

            // Replace variables
            Object.entries(vars).forEach(([k, v]) => {
                text = text.replace(`{${k}}`, v);
            });

            return text;
        }

        // Get species name in current language
        function getSpeciesName(scientificName) {
            if (speciesNames[scientificName]) {
                return speciesNames[scientificName].name;
            }
            return scientificName;
        }

        // Set language
        async function setLanguage(lang) {
            currentLang = lang;
            document.documentElement.lang = lang;

            // Update button states
            document.getElementById('langDe').classList.toggle('active', lang === 'de');
            document.getElementById('langEn').classList.toggle('active', lang === 'en');

            // Save preference
            document.cookie = `lang=${lang};path=/;max-age=${365*24*60*60}`;

            // Load translations from API
            try {
                const [transResponse, speciesResponse] = await Promise.all([
                    fetch(`${API_BASE}/api/v1/i18n/translations?lang=${lang}`),
                    fetch(`${API_BASE}/api/v1/i18n/species-names?lang=${lang}`)
                ]);

                if (transResponse.ok) {
                    const data = await transResponse.json();
                    translations = flattenTranslations(data.translations);
                }

                if (speciesResponse.ok) {
                    const data = await speciesResponse.json();
                    speciesNames = data.species;
                }
            } catch (error) {
                console.log('Using fallback translations');
            }

            // Update UI
            updateTranslations();
            updateUI();
        }

        // Flatten nested translation object
        function flattenTranslations(obj, prefix = '') {
            const result = {};
            for (const [key, value] of Object.entries(obj)) {
                const newKey = prefix ? `${prefix}.${key}` : key;
                if (typeof value === 'object' && value !== null) {
                    Object.assign(result, flattenTranslations(value, newKey));
                } else {
                    result[newKey] = value;
                }
            }
            return result;
        }

        // Update all translatable elements
        function updateTranslations() {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                el.textContent = t(key);
            });

            // Update connection status
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            if (statusDot.classList.contains('connected')) {
                statusText.textContent = t('connected');
            } else {
                statusText.textContent = t('disconnected');
            }
        }

        // Get saved language preference
        function getSavedLanguage() {
            const cookies = document.cookie.split(';').reduce((acc, c) => {
                const [key, value] = c.trim().split('=');
                acc[key] = value;
                return acc;
            }, {});
            return cookies.lang || navigator.language.split('-')[0] || 'de';
        }

        // Initialize map
        function initMap() {
            map = L.map('map').setView([52.52, 13.405], 10);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            // Custom marker icon
            window.birdIcon = L.divIcon({
                className: 'bird-marker',
                html: 'üê¶',
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });
        }

        // Initialize chart
        function initChart() {
            const ctx = document.getElementById('speciesChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: [
                            '#4ecdc4', '#ff6b6b', '#51cf66', '#ffd93d',
                            '#6c5ce7', '#a8e6cf', '#ff8b94', '#dcedc1'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#aaa',
                                font: { size: 10 }
                            }
                        }
                    }
                }
            });
        }

        // Connect WebSocket
        function connectWebSocket() {
            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                console.log('WebSocket connected');
                document.getElementById('statusDot').classList.add('connected');
                document.getElementById('statusText').textContent = t('connected');
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                document.getElementById('statusDot').classList.remove('connected');
                document.getElementById('statusText').textContent = t('disconnected');

                // Reconnect after 3 seconds
                setTimeout(connectWebSocket, 3000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);

                if (message.type === 'prediction') {
                    handlePrediction(message.data, message.device_id);
                }
            };

            // Keep-alive ping
            setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send('ping');
                }
            }, 30000);
        }

        // Handle new prediction
        function handlePrediction(data, deviceId) {
            // Activate pulse
            const pulse = document.getElementById('pulseIndicator');
            pulse.classList.add('active');
            setTimeout(() => pulse.classList.remove('active'), 1000);

            // Get localized species name
            const displayName = getSpeciesName(data.species) || data.species;

            // Update current detection
            document.getElementById('currentSpecies').textContent = displayName;
            document.getElementById('currentConfidence').textContent =
                `${(data.confidence * 100).toFixed(1)}% ${t('confidence')}`;

            // Update model badges
            const badgesContainer = document.getElementById('modelBadges');
            badgesContainer.innerHTML = data.models.map(m => {
                const agree = m.species === data.species;
                const modelSpecies = getSpeciesName(m.species) || m.species;
                return `<div class="model-badge ${agree ? 'agree' : ''}">
                    ${m.name}: ${modelSpecies || 'N/A'} (${(m.confidence * 100).toFixed(0)}%)
                </div>`;
            }).join('');

            // Add to detections
            detections.unshift({
                ...data,
                displayName,
                timestamp: new Date(),
                deviceId
            });

            // Limit detections
            if (detections.length > 100) {
                detections.pop();
            }

            // Update species counts
            speciesCounts[displayName] = (speciesCounts[displayName] || 0) + 1;

            // Add marker to map
            if (data.latitude && data.longitude) {
                const marker = L.marker([data.latitude, data.longitude], {
                    icon: L.divIcon({
                        className: 'bird-marker',
                        html: BIRD_ICONS[displayName] || BIRD_ICONS[data.species] || BIRD_ICONS.default,
                        iconSize: [30, 30],
                        iconAnchor: [15, 15]
                    })
                }).addTo(map);

                marker.bindPopup(`
                    <strong>${displayName}</strong><br>
                    ${t('confidence')}: ${(data.confidence * 100).toFixed(1)}%<br>
                    ${new Date().toLocaleTimeString()}
                `);

                markers.push(marker);

                // Limit markers on map
                if (markers.length > 50) {
                    map.removeLayer(markers.shift());
                }

                // Pan to new marker
                map.panTo([data.latitude, data.longitude]);
            }

            updateUI();
        }

        // Update UI elements
        function updateUI() {
            // Update stats
            document.getElementById('statTotal').textContent = detections.length;
            document.getElementById('statSpecies').textContent = Object.keys(speciesCounts).length;

            const avgConf = detections.length > 0
                ? detections.reduce((sum, d) => sum + d.confidence, 0) / detections.length
                : 0;
            document.getElementById('statAvgConf').textContent = `${(avgConf * 100).toFixed(0)}%`;

            // Calculate agreement rate
            const agreements = detections.filter(d => {
                const parts = d.agreement?.split('/') || ['0', '1'];
                return parts[0] === parts[1];
            }).length;
            const agreementRate = detections.length > 0 ? (agreements / detections.length) : 0;
            document.getElementById('statAgreement').textContent = `${(agreementRate * 100).toFixed(0)}%`;

            // Update map count
            document.getElementById('mapCount').textContent = t('points', { n: markers.length });

            // Update timeline
            const timelineList = document.getElementById('timelineList');
            timelineList.innerHTML = detections.slice(0, 20).map((d, i) => {
                const displayName = d.displayName || getSpeciesName(d.species) || d.species;
                return `
                <div class="timeline-item ${i === 0 ? 'new' : ''}">
                    <div class="timeline-icon">${BIRD_ICONS[displayName] || BIRD_ICONS[d.species] || BIRD_ICONS.default}</div>
                    <div class="timeline-content">
                        <div class="timeline-species">${displayName}</div>
                        <div class="timeline-meta">${d.timestamp.toLocaleTimeString()}</div>
                    </div>
                    <div class="timeline-confidence">${(d.confidence * 100).toFixed(0)}%</div>
                </div>
            `}).join('');

            document.getElementById('timelineCount').textContent = detections.length;

            // Update chart
            const sortedSpecies = Object.entries(speciesCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 6);

            chart.data.labels = sortedSpecies.map(s => s[0]);
            chart.data.datasets[0].data = sortedSpecies.map(s => s[1]);
            chart.update();
        }

        // Load historical data
        async function loadHistoricalData() {
            try {
                // Load map points
                const mapResponse = await fetch(`${API_BASE}/api/v1/recordings/map/points?limit=50`);
                if (mapResponse.ok) {
                    const points = await mapResponse.json();
                    points.forEach(point => {
                        if (point.lat && point.lon) {
                            const displayName = getSpeciesName(point.species) || point.species;
                            const marker = L.marker([point.lat, point.lon], {
                                icon: L.divIcon({
                                    className: 'bird-marker',
                                    html: BIRD_ICONS[displayName] || BIRD_ICONS[point.species] || BIRD_ICONS.default,
                                    iconSize: [30, 30],
                                    iconAnchor: [15, 15]
                                })
                            }).addTo(map);

                            marker.bindPopup(`
                                <strong>${displayName}</strong><br>
                                ${t('confidence')}: ${(point.confidence * 100).toFixed(1)}%
                            `);

                            markers.push(marker);
                        }
                    });
                }

                // Load timeline
                const timelineResponse = await fetch(`${API_BASE}/api/v1/recordings/timeline?hours=24`);
                if (timelineResponse.ok) {
                    const timeline = await timelineResponse.json();
                    timeline.forEach(entry => {
                        const displayName = getSpeciesName(entry.species) || entry.species;
                        detections.push({
                            species: entry.species,
                            displayName,
                            confidence: entry.confidence,
                            timestamp: new Date(entry.timestamp),
                            agreement: `${entry.models_agreed}/2`
                        });

                        speciesCounts[displayName] = (speciesCounts[displayName] || 0) + 1;
                    });
                }

                updateUI();

                // Fit map to markers
                if (markers.length > 0) {
                    const group = L.featureGroup(markers);
                    map.fitBounds(group.getBounds().pad(0.1));
                }

            } catch (error) {
                console.error('Failed to load historical data:', error);
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            // Set initial language
            const savedLang = getSavedLanguage();
            await setLanguage(savedLang === 'de' || savedLang === 'en' ? savedLang : 'de');

            initMap();
            initChart();
            connectWebSocket();
            loadHistoricalData();
        });
    </script>
</body>
</html>
